---
title: "Math189_Homework03"
output: html_document
---


```{r}
#Set up environment
library(lattice)
library(truncnorm)
set.seed(318)

#Colors for graphs
lt.blue <- rgb(173,216,230,max = 255, alpha = 85, names = "lt.blue")
lt.pink <- rgb(255,192,203, max = 255, alpha = 85, names = "lt.pink")

#Create directory to save graphs 
dir.create(file.path("graphs"), showWarnings = FALSE)

#Read in the data
data <- read.table("hcmv.txt", header=TRUE)
locations <- data$location
data
locations
```


```{r}
#SCENARIO 1

# biologists conjectured that clusters of palindromes in CMV may serve the same role as the single long 
# palindrome in Herpes simplex, which is used to help find the origin of replication
# Hence, we begin by looking at the distribution of palindromes to see if we can make any observations about the type

#Our Data
#Scatter
stripplot(data$location, pch=16, cex=0.25, main="Data Locations Scatter")
dev.copy(png,'graphs/scen1datastrip.png')
dev.off()
#Histogram
data.hist <- hist(data$location, breaks=seq(0,240000,4000), xaxt="n", main="Data Locations Histogram")
axis(side=1, at=seq(0, 240000, 12000), las=2)
dev.copy(png,'graphs/scen1datahist.png')
dev.off()

#Simulated Data (based on DI6)
N <- 229354 #total length of CMV DNA
n <- 296 #number of palindromes found that were > 10 letters
sim.gene <- seq(1, N)

#Random/Uniform
site.random <- sample.int(N, size=n) 
#Random Scatter
stripplot(site.random, pch=16, cex=0.25, main="Random Locations Scatter")
dev.copy(png,'graphs/scen1randomstrip.png')
dev.off()
#Histogram
random.hist <- hist(site.random, breaks=seq(0,240000,4000), xaxt="n", main="Random Locations Histogram")
axis(side=1, at=seq(0, 240000, 12000), las=2)
dev.copy(png,'graphs/scen1randomhist.png')
dev.off()

#Normal
norm.quant <- seq(-3, 3, length.out=N)
site.norm <- sample.int(N, size=n, prob=dnorm(norm.quant))
#Scatter
stripplot(site.norm, pch=16, cex=0.25, main="Normal Locations Scatter")
dev.copy(png,'graphs/scen1normalstrip.png')
dev.off()
#Histogram
normal.hist <- hist(site.norm, breaks=seq(0,240000,4000), xaxt="n", main="Normal Locations Histogram")
axis(side=1, at=seq(0, 240000, 12000), las=2)
dev.copy(png,'graphs/scen1normalhist.png')
dev.off()

#BiModal
betas <- rbeta(n,2,2)
b1 <- betas[0:(2 *n/3)]*186000
b2 <-betas[(2 *n/3):n]*90000+150000
site.bimodal <- c(b1, b2)
#Scatter
stripplot(site.bimodal, pch=16, cex=0.25, main="Bimodal Locations Scatter")
dev.copy(png,'graphs/scen1bimodalstrip.png')
dev.off()
#Histogram
bimod.hist <- hist(site.bimodal, breaks=seq(0,240000,4000), xaxt="n", main="Bimodal Locations Histogram")
axis(side=1, at=seq(0, 240000, 12000), las=2)
dev.copy(png,'graphs/scen1bimodalhist.png')
dev.off()

#Weighted Random
gene.double <- locations
gene.weight <- rep(0.5, N)
gene.weight[gene.double] <- gene.weight[gene.double] + 0.5
#Creating 5 random simulations, where location of actual palindrome twice as likely to be picked
sim1 <- c(sample.int(N, size=n, prob=gene.weight))
sim2 <- c(sample.int(N, size=n, prob=gene.weight))
sim3 <- c(sample.int(N, size=n, prob=gene.weight))
sim4 <- c(sample.int(N, size=n, prob=gene.weight))
sim5 <- c(sample.int(N, size=n, prob=gene.weight))
site.weight <- data.frame(sim1, sim2, sim3, sim4, sim5)
site.weight
#Scatter
stripplot(site.weight$sim1, pch=16, cex=0.25, main="Weighted Random Locations Scatter")
dev.copy(png,'graphs/scen1weightstrip.png')
dev.off()
#Histogram
weighted.hist <- hist(site.weight$sim1, breaks=seq(0,240000,4000), xaxt="n", main="Weighted Random Locations Histogram")
axis(side=1, at=seq(0, 240000, 12000), las=2)
dev.copy(png,'graphs/scen1weighthist.png')
dev.off()

#Overlaying histograms
#Data vs Normal
plot(normal.hist, col = lt.pink, xaxt="n", main="Data vs Normal Locations") 
plot(data.hist, col = lt.blue, add = TRUE)
axis(side=1, at=seq(0, 240000, 12000), las=2)
legend("topright", c("Data", "Normal"), col=c(lt.blue, lt.pink), lwd=10, border="black")
dev.copy(png,'graphs/scen1datanormalhist.png')
dev.off()
#Data vs Random
plot(data.hist, col = lt.blue, xaxt="n", main="Data vs Random Locations") 
plot(random.hist, col = lt.pink, add = TRUE)
axis(side=1, at=seq(0, 240000, 12000), las=2)
legend("topleft", c("Data", "Random"), col=c(lt.blue, lt.pink), lwd=10, border="black")
dev.copy(png,'graphs/scen1datarandmohist.png')
dev.off()
#Data vs Bimodal
plot(data.hist, col = lt.blue, xaxt="n", main="Data vs Bimodal Locations") 
plot(bimod.hist, col = lt.pink, add = TRUE)
axis(side=1, at=seq(0, 240000, 12000), las=2)
legend("topright", c("Data", "Bimodal"), col=c(lt.blue, lt.pink), lwd=10, border="black")
dev.copy(png,'graphs/scen1databimodalhist.png')
dev.off()
#Data vs Weighted
plot(data.hist, col = lt.blue, xaxt="n", main="Data vs Weighted Random Locations") 
plot(weighted.hist, col = lt.pink, add = TRUE)
axis(side=1, at=seq(0, 240000, 12000), las=2)
legend("topright", c("Data", "Weighted"), col=c(lt.blue, lt.pink), lwd=10, border="black")
dev.copy(png,'graphs/scen1dataweighthist.png')
dev.off()
```

```{r}
### SCENARIO 2 ####

# ooooh maybe graph dot plot with x = location and y = distance
plot(data)
# Well that was useless...


#Function to find distances between locations of palindromes
distcalc <- function(dat) {
  distances=c()
  distances[1] = dat[1]
  for (i in 2:length(dat)) { 
    distances[i]=dat[i]-dat[i-1]
  }
  return(distances)
}

#Update main data's dataframe to include distances for analysis 
data$distances = distcalc(locations)
data

#create df for simulation distances
sim1d <- distcalc(sort(sim1))
sim2d <- distcalc(sort(sim2))
sim3d <- distcalc(sort(sim3))
sim4d <- distcalc(sort(sim4))
sim5d <- distcalc(sort(sim5))
weight.distances <- data.frame(sim1d, sim2d, sim3d, sim4d, sim5d)
weight.distances


# Distance Histograms function (with bins=200)
distgraphs <- function(dat, word, c) {
  ti <- paste("Distances Between Palidromes (", word, ")", sep = "", collapse = NULL)
  hist(dat, breaks=seq(0,5600,200), xaxt="n", main=ti, xlab="Distance from Last Palindrome", ylab="Count", col = c)
  axis(side=1, at=seq(0, 5600, 600), las=2)
}

distgraphs(data$distances, "Data", "gray")
dev.copy(png,'graphs/scen2distdata.png')
dev.off()
distgraphs(sim1d, "Sim 1", "red")
dev.copy(png,'graphs/scen2distsim1.png')
dev.off()
distgraphs(sim2d, "Sim 2", "orange")
dev.copy(png,'graphs/scen2distsim2.png')
dev.off()
distgraphs(sim3d, "Sim 3", "yellow")
dev.copy(png,'graphs/scen2distsim3.png')
dev.off()
distgraphs(sim4d, "Sim 4", "green")
dev.copy(png,'graphs/scen2distsim4.png')
dev.off()
distgraphs(sim5d, "Sim 5", "blue")
dev.copy(png,'graphs/scen2distsim5.png')
dev.off()




```

```{r}
### SCENARIO 3 ####
# NON OVERLAPPING INTERVAL COUNTS
regionsplit <- function(n.region, gene, site){
  count.int <- table(cut(site, breaks = seq(1, length(gene), length.out=n.region+1), include.lowest=TRUE))
  count.vector <- as.vector(count.int)
  count.tab <- table(count.vector)
  return (count.tab)
}

#picking num regions (lets say 45?)
#random vector
n.region <- 45
regionsplit(n.region, sim.gene, site.random)
#normal vector
regionsplit(n.region, sim.gene, site.norm)
#weighted vectors 
regionsplit(n.region, sim.gene, site.weight$sim1)
regionsplit(n.region, sim.gene, site.weight$sim2)
regionsplit(n.region, sim.gene, site.weight$sim3)
regionsplit(n.region, sim.gene, site.weight$sim4)
regionsplit(n.region, sim.gene, site.weight$sim5)
#X^2 test
chisqtable <- function(n.region, site, N){
  n <- length(site)
  # lambda estimate
  lambda.est <- n/n.region
  # cut into n.region number of non-overlapping intervals
  count.int <- table(cut(site, breaks = seq(1, length(sim.gene), length.out=n.region+1), include.lowest=TRUE))
  # get the count levels range
  count.vector <- as.vector(count.int)
  count.range <- max(count.vector) - min(count.vector) + 1
  
  # create contingency table
  table <- matrix(rep(NA, count.range*3), count.range, 3)
  for (i in 1:count.range){
    offset <- min(count.vector) - 1
    # first column = count level
    table[i, 1] <- i + offset
    # second column = observed count
    table[i, 2] <- sum(count.vector == i + offset)
    # third column = expected count
    if (i + offset == min(count.vector) && (min(count.vector) != 0))
      table[i, 3] <- ppois(i+offset, lambda.est)*n.region
    else if (i + offset == max(count.vector))
      table[i, 3] <- (1 - ppois(i + offset - 1, lambda.est))*n.region
    else
      table[i, 3] <- (ppois(i+offset, lambda.est) - ppois(i + offset - 1, lambda.est))*n.region
  }
  
  return (table)
}
# Random Chi-Square table
site.random.tabtemp <- chisqtable(n.region, site.random, N)
# Normal Chi Sq Table
site.norm.tabtemp <- chisqtable(n.region, site.norm, N)
# Weighted Chi-Squared Tables
site.weight1.tabtemp <- chisqtable(n.region, site.weight$sim1, N)
site.weight2.tabtemp <- chisqtable(n.region, site.weight$sim2, N)
site.weight3.tabtemp <- chisqtable(n.region, site.weight$sim3, N)
site.weight4.tabtemp <- chisqtable(n.region, site.weight$sim4, N)
site.weight5.tabtemp <- chisqtable(n.region, site.weight$sim5, N)
site.weight1.tabtemp
#We can group together intervals 
#chi sq test for uniformly randomly selected gene locations
site.random.tab <- matrix(rep(NA, 7*2), 7, 2)
site.random.tab[1,] <- colSums(site.random.tabtemp[1:4, 2:3])
site.random.tab[2:6,] <- site.random.tabtemp[5:9, 2:3]
site.random.tab[7,] <- colSums(site.random.tabtemp[10:11, 2:3])
site.random.stats <- sum((site.random.tab[,2] - site.random.tab[,1])^2/site.random.tab[,2])
pchisq(site.random.stats, 7 - 2, lower.tail=FALSE)

site.norm.tab <- matrix(rep(NA, 7*2), 7, 2)
site.norm.tab[1,] <- colSums(site.norm.tabtemp[1:4, 2:3])
site.norm.tab[2:6,] <- site.norm.tabtemp[5:9, 2:3]
site.norm.tab[7,] <- colSums(site.norm.tabtemp[10:19, 2:3])
site.norm.stats <- sum((site.norm.tab[,2] - site.norm.tab[,1])^2/site.norm.tab[,2])
pchisq(site.norm.stats, 7 - 2, lower.tail=FALSE)

site.weight1.tab <- matrix(rep(NA, 7*2), 7, 2)
site.weight1.tab[1,] <- colSums(site.weight1.tabtemp[1:4, 2:3])
site.weight1.tab[2:6,] <- site.weight1.tabtemp[5:9, 2:3]
site.weight1.tab[7,] <- colSums(site.weight1.tabtemp[10:11, 2:3])
site.weight1.stats <- sum((site.weight1.tab[,2] - site.weight1.tab[,1])^2/site.weight1.tab[,2])
pchisq(site.weight1.stats, 7 - 2, lower.tail=FALSE)

site.weight2.tab <- matrix(rep(NA, 7*2), 7, 2)
site.weight2.tab[1,] <- colSums(site.weight2.tabtemp[1:4, 2:3])
site.weight2.tab[2:6,] <- site.weight2.tabtemp[5:9, 2:3]
site.weight2.tab[7,] <- colSums(site.weight2.tabtemp[10:11, 2:3])
site.weight2.stats <- sum((site.weight2.tab[,2] - site.weight2.tab[,1])^2/site.weight2.tab[,2])
pchisq(site.weight2.stats, 7 - 2, lower.tail=FALSE)
```